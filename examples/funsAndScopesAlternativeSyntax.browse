# Create a scope
scope math {
  vars {
    PI 3.14
    e 2.718
  }
  private { } # a.k.a internal
  rules {
    abs {
      bind $x
      # TODO: somehow eval Math.abs(x) in javascript and return that
      return $x
    }
  }
}

#You can define rules that reference any other scope with the 
#'uses' keyword, this is implemented as part of the 'rule' Rule
rule pow {
  bind x y
  if ($y == 0) then { return 1 }
  
  # We can even use the `abs` rule that's only available in the math scope
  set recursed ( pow $x ( abs $y / 2 ) )

  if ($y % 2 == 0) then {
    return $recursed * $recursed
  } else {
    set v 
    return $x * $recursed * $recursed
  }
} uses math;

##This is fine
using math {
  pow 2 8
}

pow 2 8
# ERROR: 'Rule pow is not defined in the current scope. Trying running pow in one of these scopes (Grab scopes where pow is deifined)'




#Alternative syntax which is also valid at the top of a browse file
#
with math;
with fs;
with net;


#We are able to use pow
pow 2 3

#Opening/clsing/writing to  files is allowed bc we're in an fs scope
fOpen 'out.txt' 'Hello World'
fWrite 'out.txt' 'Hello World' 'a+'
fClose 'out.txt'
fetch 'https://google.com'

#The above code would be the same as writing
#NOTE: We would have to take care to make nesting idempotent so the order of imports doesn't matter
using math {
  using fs {
    using net {
      #We are able to use pow
      pow 2 3
      
      #Opening/clsing/writing to  files is allowed bc we're in an fs scope
      fOpen 'out.txt' 'Hello World'
      fWrite 'out.txt' 'Hello World' 'a+'
      fClose 'out.txt'
      fetch 'https://google.com'

    }
  }
}



rule waitAndClick {
  bind ms selector
  wait $ms
  click $selector
} uses page

#Exponential backoff for click uses both the math and the page scope.
rule exponentalBackoffClick {
  bind selector, initWait;

  while (true) {
    try {
      click $selector
    } catch {
      wait initWait;
      set initWait (pow initWait 2);
    }
  }
} uses page math
