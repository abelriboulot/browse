##################
##### PREFACE ####
##################

# Create a scope
scope math {
  vars {
    PI 3.14
    e 2.718
  }
  private { } # a.k.a internal
  rules {
    abs {
      bind $x
      # TODO: somehow eval Math.abs(x) in javascript and return that
      return $x
    }
  }
}

############################################
############################################

# We can extend the match scope directly and create additional rules that are
# available whenever we're in a match scope
extend math {
  rules {
    # Not the real implementation we use because Math.pow in JS is far
    # more efficient but this serves as a good example, that's all
    pow {
      bind x y
      if ($y == 0) then { return 1 }
      
      # We can even use the `abs` rule that's only available in the math scope
      set recursed ( pow $x ( abs $y / 2 ) )

      if ($y % 2 == 0) then {
        return $recursed * $recursed
      } else {
        set v 
        return $x * $recursed * $recursed
      }
    }
  }
}

using math {
  pow 2 8
}

############################################
############################################

# Instead of extending a scope, which feels quite OOP, rules can do 2 new
# things: 
#   1. They can define which scope they are accessible in. This way, they still
#      need to be independently imported, passed around, etc. However, they can
#      only be evaluated in a context where the page scope is an ancestor. 
#   2. Rules that take RuleSets as an argument and then evaluate them must
#      define what scope each RuleSet will be evaluated under

# 1.
rule(scope=math) pow {
  # ... same as above
}

# This would throw an error
pow 2 8

# However

# 2. 
rule(runtimes=[, math]) inMath {
  bind someRandomArg nestedRuleSet
  return evalRuleSet $nestedRuleSet
}

inMath ignoreThisString {
  # In here, we have access to abs
  abs 4.5

  # Also, while the scope doesn't provide `pow`, we can still use the `pow` rule
  # here because the rule itself is available in the lexical scope, and we are
  # in a ruleset that is in the math scope
  pow 2 8
}


# Known Limitations
#  1. What about rules that rely on multiple scopes in their ancestory? For
#     instance, `waitAndVisit`, a rule in the `page` scope that relies on `wait`
#     (from the page scope) and `visit` (from the browser scope)
#  2. When a rule accepts more than one RuleSet as an argument and plans to
#     evaluate them, there are multiple ways the scopes can actually get used.
#     For example, the `for` rule, which takes 2 rulesets, injects a `test` rule
#     into the first RuleSet, but doesn't do that into the second RuleSet.
#     However, both RuleSets need to share their variables so that `i`, defined
#     by `set i 0` in the iterator RuleSet, is still accessible in the body
#     RuleSet

# An attempt to create the `waitAndVisit` rule described above and ideas to
# solve these limitations

# providing multiple scopes that should be available for a rule to work
rule(scope=[browser,page]) waitAndVisit {
  # ...
}

# The definition for the page rule would list multiple runtimes for a RuleSet
rule(runtimes=[,[browser,page]]) page {
  bind pattern handler
  # ...
  evalRuleSet $handler
  return nil
}

# now, if a scopes's rules actually rely on another scope, it can define that
# using `requred`
scope advMath {
  requires math
  rules {
    round {
      bind $x
      set $a (abs $x)
      if ($x * 2 >= ($a * 2 + 1)) then {
        return $a
      } else {
        return $a + 1
      }
    }
  }
}

# any function that actually defines runtimes, can specify multiple 


############################################
############################################

# Explicitly passing the scope
rule waitAndVisit {
  bind scope ms url
  
  # using is a special rule. While we normally have lexical scoping, `using` is
  # the escape hatch that lets us explicity live in another scope
  using $scope {    
    # inside here, we cannot statically determine what rules and vars are
    # accessible

    wait $ms
    visit $url
  }

  # but this bit can only access what's lexically available
}

page https://windsor.io {
  # scope is a std rule that just returns the current scope
  waitAndVisit ( scope ) 100 https://app.windsor.io
}

############################################
############################################

# Defining the specific requirements for a rule. The specific rules will be
# provided via dependency injection

rule waitAndVisit {
  # We're defining just the specifc requirements for any scope that wishes to
  # evaluate this rule. It doesn't matter WHAT scope provides these (whether
  # it's a page or otherwise), just that it exists
  expects {
    vars { }
    rules {
      wait
      visit
    }
  }

  bind ms url
  
  # `expects` a language level feature (not just another rule), so we can
  # statically guarentee at this point that two rules, called `wait` and `visit`
  # are available
  wait $ms
  visit $url
}


# This won't work
waitAndVisit 12 https://google.com

# however, if we just defined the necessary rules
rule wait {}
rule visit {}

# now, since the current scope matches the requirements, ew can use the rule
waitAndVisit 12 https://google.com

# when waitAndVisit above is evaluated, the internal mechanics will 
#   1. create a blank scope that inherits from `waitAndVisit`'s lexical scope
#   2. inject `wait` and `visit` from the current call scope into the blank scope
#   3. evaluate the rule


