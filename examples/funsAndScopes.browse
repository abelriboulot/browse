##################
##### PREFACE ####
##################

# Create a scope
scope math {
  vars {
    PI 3.14
    e 2.718
  }
  private { } # a.k.a internal
  rules {
    abs {
      bind $x
      # TODO: somehow eval Math.abs(x) in javascript and return that
      return $x
    }
  }
}

############################################
############################################

# We can extend the match scope directly and create additional rules that are
# available whenever we're in a match scope
extend math {
  rules {
    # Not the real implementation we use because Math.pow in JS is far
    # more efficient but this serves as a good example, that's all
    pow {
      bind x y
      if ($y == 0) then { return 1 }
      
      # We can even use the `abs` rule that's only available in the math scope
      set recursed ( pow $x ( abs $y / 2 ) )

      if ($y % 2 == 0) then {
        return $recursed * $recursed
      } else {
        set v 
        return $x * $recursed * $recursed
      }
    }
  }
}

using math {
  pow 2 8
}

############################################
############################################

# Instead of extending a scope, which feels quite OOP, rules can do 2 new
# things: 
#   1. They can define which scope they are accessible in. This way, they still
#      need to be independently imported, passed around, etc. However, they can
#      only be evaluated in a context where the page scope is an ancestor. 
#   2. Rules that take RuleSets as an argument and then evaluate them must
#      define what scope each RuleSet will be evaluated under

# 1.
rule(scope=math) pow {
  # ... same as above
}

# This would throw an error
pow 2 8

# However

# 2. 
rule(runtimes=[, math]) inMath {
  bind someRandomArg nestedRuleSet
  return evalRuleSet $nestedRuleSet
}

inMath ignoreThisString {
  # In here, we have access to abs
  abs 4.5

  # Also, while the scope doesn't provide `pow`, we can still use the `pow` rule
  # here because the rule itself is available in the lexical scope, and we are
  # in a ruleset that is in the math scope
  pow 2 8
}


# Known Limitations
#  1. What about rules that rely on multiple scopes in their ancestory? For
#     instance, `waitAndVisit`, a rule in the `page` scope that relies on `wait`
#     (from the page scope) and `visit` (from the browser scope)
#  2. When a rule accepts more than one RuleSet as an argument and plans to
#     evaluate them, there are multiple ways the scopes can actually get used.
#     For example, the `for` rule, which takes 2 rulesets, injects a `test` rule
#     into the first RuleSet, but doesn't do that into the second RuleSet.
#     However, both RuleSets need to share their variables so that `i`, defined
#     by `set i 0` in the iterator RuleSet, is still accessible in the body
#     RuleSet

# An attempt to create the `waitAndVisit` rule described above and ideas to
# solve these limitations

# providing multiple scopes that should be available for a rule to work
rule(scope=[browser,page]) waitAndVisit {
  # ...
}

# The definition for the page rule would list multiple runtimes for a RuleSet
rule(runtimes=[,[browser,page]]) page {
  bind pattern handler
  # ...
  evalRuleSet $handler
  return nil
}

# now, if a scopes's rules actually rely on another scope, it can define that
# using `requred`
scope advMath {
  requires math
  rules {
    round {
      bind $x
      set $a (abs $x)
      if ($x * 2 >= ($a * 2 + 1)) then {
        return $a
      } else {
        return $a + 1
      }
    }
  }
}

# any function that actually defines runtimes, can specify multiple 


############################################
############################################

# Explicitly passing the scope
rule waitAndVisit {
  bind scope ms url
  
  # using is a special rule. While we normally have lexical scoping, `using` is
  # the escape hatch that lets us explicity live in another scope
  using $scope {    
    # inside here, we cannot statically determine what rules and vars are
    # accessible

    wait $ms
    visit $url
  }

  # but this bit can only access what's lexically available
}

page https://windsor.io {
  # scope is a std rule that just returns the current scope
  waitAndVisit ( scope ) 100 https://app.windsor.io
}

############################################
############################################

# 2 syntaxes
#   1. A rule explicity defines its dependencies. browse injects those into the
#      rule whenever the rule is evaluated. The caller doesn't need to do
#      anything special, aside from having the needed rules and vars in its
#      scope
#   2. A rule that takes a RuleSet as a parameter explicity injects a scope into
#      the RuleSet. This is why Rulesets like the one that are passed into page
#      DON'T need to be explicit about its dependencies (that would be ugly)


# Syntax 1:

rule waitAndVisit {
  # We're defining the specifc requirements for this rule. Whenever this rule is
  # evaluated, browse will ensure that the dependencies exist in the caller's
  # scope before injecting them. It doesn't matter what scope provides these
  # (whether it's a page or otherwise), just that it exists
  expects {
    vars { } # this line is not needed here, but I'm adding it for completeness
    rules {
      wait
      visit
    }
  }

  bind ms url
  
  wait $ms
  visit $url
}


# This won't work
waitAndVisit 12 https://google.com

# however, if we just defined the necessary rules
rule wait {}
rule visit {}

# now, since the current scope matches the requirements, we can use the rule
waitAndVisit 12 https://google.com

# when waitAndVisit above is evaluated, the internal mechanics will
#   1. create a blank scope that inherits from `waitAndVisit`'s lexical scope
#   2. inject `wait` and `visit` from the current call scope into the blank scope
#   3. evaluate the rule

page https://windsor.io {
  waitAndVisit 12 https://google.com
  # Using the same algorithm above, waitandVisit will now actually have access
  # to the real wait and visit, and not the stubs

  # ...but how come we didn't have to use `expects` inside THIS RuleSet. `visit`
  # and `wait` are just implicity accessible here! 

  # This is where the second syntax comes in. The definition of the `page` rule
  # explicitly injected the scope when evaluating this RuleSet
}

# Let's see how that works with an example

# We define a scope interface
scopeInterface mockPageScopeInterface {
  vars { url }
  rules { wait; click }
  extends browserInterface
}

rule mockPage {
  bind pattern ruleSet:mockPageScopeInterface
  # the above annotation tells us that `ruleSet` will implicitly have a scope
  # matching the `mockPageScopeInterface`. It's really just useful for
  # autocomplete, and the annotation can be remove by a compiler

  # In fact, the interface is really just a static type annotation. The compiler
  # can remove it before runtime. The `scopeInterface` rule should just be a
  # noop

  # This is the actual scope
  set mockScope {
    vars { url "mock" }
    rules { 
      wait { print "wait" }
      click { print "click" }
      visit { print "browser:visit" }
      page { print "browser:page" }
    }
  }

  # here is how we inject it before evaluating the RuleSet
  evalInScope $mockScope $ruleSet
}

# Notice how in syntax 1, it's the job of a RULE to define what it wants
# injected into it when executed and in syntax 2, a rule that evaluates a
# RULESET imperatively controls the scope in which the RuleSet is executed. This
# allows the creation of the powerful rules that browse is famous for, where a
# number of implicit vars/rules are just available